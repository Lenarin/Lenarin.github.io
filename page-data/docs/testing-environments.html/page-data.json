{"componentChunkName":"component---src-templates-docs-js","path":"/docs/testing-environments.html","result":{"data":{"markdownRemark":{"html":"<!-- Этот документ предназначен для людей, которые знают, как использовать JavaScript и умеют писать тесты. Он показывает различия в средах тестирования React-компонентов и как эти различия повлияют на тесты, которые они пишут. Документ, по большей части, про react-dom-компоненты для веб и частично про другие рендереры. -->\n<p>Этот документ рассказывает про факторы, которые могут повлиять на среду тестирования и даёт рекомендации для некоторых случаев.</p>\n<h3 id=\"test-runners\"><a href=\"#test-runners\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Исполнители тестов </h3>\n<p>Исполнители тестов, такие как <a href=\"https://jestjs.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jest</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mocha</a>, <a href=\"https://github.com/avajs/ava\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ava</a>, позволяют писать тесты на JavaScript и запускать их в процессе разработки. Кроме того, наборы тестов запускаются в рамках непрерывной интеграции.</p>\n<ul>\n<li>Jest хорошо совместим с React-проектами, поддерживает такие возможности, как фиктивные <a href=\"#mocking-modules\">модули</a> и <a href=\"#mocking-timers\">таймеры</a>, работа с <a href=\"#mocking-a-rendering-surface\"><code class=\"gatsby-code-text\">jsdom</code></a>. <strong>Если вы используете Create React App, <a href=\"https://facebook.github.io/create-react-app/docs/running-tests\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jest уже предустановлен</a> с полезными настройками по умолчанию.</strong></li>\n<li>Библиотеки, такие как <a href=\"https://mochajs.org/#running-mocha-in-the-browser\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mocha</a>, хорошо работают в среде с настоящим браузером и помогут в тестах, которым она требуется.</li>\n<li>«Сквозные» тесты нужны для тестирования длинных последовательностей действий через несколько страниц и требуют <a href=\"#end-to-end-tests-aka-e2e-tests\">другой настройки</a>.</li>\n</ul>\n<h3 id=\"mocking-a-rendering-surface\"><a href=\"#mocking-a-rendering-surface\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Подмена области рендеринга </h3>\n<p>Тесты часто запускаются в среде, у которой нет доступа к реальной области рендеринга, например браузера. В этом случае мы рекомендуем имитировать работу браузера с помощью <a href=\"https://github.com/jsdom/jsdom\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">jsdom</code></a> — легковесной реализации браузера, которая запускается в Node.js.</p>\n<p>В большинстве случаев, <code class=\"gatsby-code-text\">jsdom</code> ведёт себя как обычный браузер, но без некоторых возможностей, например <a href=\"https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">разметки и навигации</a>. Несмотря на это, <code class=\"gatsby-code-text\">jsdom</code> полезен в большинстве тестов компонентов для веб, так как выполняется быстрее, чем запуск браузера для каждого отдельного теста. Он также запускается рядом с вашими тестами, что позволяет писать код для сравнения отрендеренного DOM с ожидаемым результатом.</p>\n<p>Как настоящий браузер, <code class=\"gatsby-code-text\">jsdom</code> имитируют действия пользователя: тесты могут создавать события на DOM-узлах, наблюдать за ними и проверять предполагаемые побочные эффекты от этих действий <a href=\"/docs/testing-recipes.html#events\"><small>(пример)</small></a>.</p>\n<p>Большое количество UI-тестов можно написать описанным выше способом: Jest запускает тесты, компонент рендерится в <code class=\"gatsby-code-text\">jsdom</code>, действия пользователя описываются в виде последовательности браузерных событий и оборачиваются вспомогательной функцией <code class=\"gatsby-code-text\">act()</code> <a href=\"/docs/testing-recipes.html#act\"><small>(пример)</small></a>. Кстати, много тестов для библиотеки React написано таким образом.</p>\n<p>Если вы пишете библиотеку, которая в основном тестирует поведение специфичное для браузера, например, работа с разметкой страницы или настоящие элементы <code class=\"gatsby-code-text\">input</code>, используйте фреймворк, такой как <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mocha.</a></p>\n<p>В среде, где вы <em>не можете</em> имитировать DOM (например, тестирование компонентов React Native в Node.js), используйте <a href=\"/docs/test-utils.html#simulate\">вспомогательные функции имитации события</a>, чтобы имитировать взаимодействие с элементами. В качестве альтернативы можно использовать вспомогательную функцию <code class=\"gatsby-code-text\">fireEvent</code> из <a href=\"https://testing-library.com/docs/react-native-testing-library/intro\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">@testing-library/react-native</code></a>.</p>\n<p>Фреймворки, такие как <a href=\"https://www.cypress.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Cypress</a>, <a href=\"https://github.com/GoogleChrome/puppeteer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">puppeteer</a> и <a href=\"https://www.seleniumhq.org/projects/webdriver/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">webdriver</a> полезны для запуска <a href=\"#end-to-end-tests-aka-e2e-tests\">«сквозных» тестов</a>.</p>\n<h3 id=\"mocking-functions\"><a href=\"#mocking-functions\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Подмена функций </h3>\n<p>При написании тестов иногда требуется подменить части кода, которые не имеют аналога внутри среды тестирования (например, проверка статуса через <code class=\"gatsby-code-text\">navigator.onLine</code> внутри Node.js). Тесты могут «следить» за некоторыми функциями и видеть, как другие части теста взаимодействуют с ними. В этом случае полезно иметь возможность выборочно подменять эти функции на удобные для тестирования версии.</p>\n<p>Это особенно удобно при получении данных. Обычно, предпочтительнее использовать «подставные» данные для тестов, чтобы избежать замедления и странного поведения, чем получать данные из настоящих API. <a href=\"/docs/testing-recipes.html#data-fetching\"><small>(пример)</small></a>. Это сделает тесты более предсказуемыми. Библиотеки, такие как <a href=\"https://jestjs.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jest</a> и <a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sinon</a>, поддерживают подмену функций. В «сквозных» тестах, подменить сетевой интерфейс будет тяжелее, но вы, возможно, захотите протестировать и настоящие API в таких тестах.</p>\n<h3 id=\"mocking-modules\"><a href=\"#mocking-modules\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Фиктивные модули </h3>\n<p>Некоторые компоненты имеют зависимости в виде модулей, которые могут неправильно работать внутри тестовой среды или совсем не нужны при тестировании. Выборочная подмена таких модулей на фиктивные может быть полезна <a href=\"/docs/testing-recipes.html#mocking-modules\"><small>(пример)</small></a>.</p>\n<p>В Node.js исполнители тестов, например Jest <a href=\"https://jestjs.io/docs/ru/manual-mocks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">поддерживает фиктивные модули</a>. Также вы можете использовать библиотеки, такие как <a href=\"https://www.npmjs.com/package/mock-require\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">mock-require</code></a>.</p>\n<h3 id=\"mocking-timers\"><a href=\"#mocking-timers\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Фиктивные таймеры </h3>\n<p>Компоненты могут использовать функции, связанные с временем, такие как <code class=\"gatsby-code-text\">setTimeout</code>, <code class=\"gatsby-code-text\">setInterval</code> или <code class=\"gatsby-code-text\">Date.now</code>. В средах тестирования может быть полезно подменить такие функции на фиктивные, что позволит «двигаться» во времени. Это отличный способ ускорить выполнение тестов! Тесты с таймерами будут по-прежнему выполнятся по порядку, только быстрее. <a href=\"/docs/testing-recipes.html#timers\"><small>(пример)</small></a>. Большинство фреймворков, включая <a href=\"https://jestjs.io/docs/en/timer-mocks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jest</a>, <a href=\"https://sinonjs.org/releases/v7.3.2/fake-timers/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sinon</a> и <a href=\"https://github.com/sinonjs/lolex\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lolex</a>, позволяют подменять таймеры в тестах.</p>\n<p>Иногда фиктивные таймеры не нужны. Например, при тестировании анимации или взаимодействии с удалённым API, который чувствителен к времени (имеет ограничение по частоте доступа). Библиотеки с фиктивными таймерами позволяют включать и выключать их для одного теста или набора в целом, так что вы можете явно указать как эти тесты будут исполняться.</p>\n<h3 id=\"end-to-end-tests-aka-e2e-tests\"><a href=\"#end-to-end-tests-aka-e2e-tests\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>«Сквозные» тесты </h3>\n<p>«Сквозные» тесты полезны при тестировании длинных последовательностей действий, особенно тех, что важны для бизнеса (таких как платежи или регистрация пользователей). Для таких тестов, вы скорее всего, хотите протестировать рендеринг всего приложения в настоящем браузере, получение данных из настоящих API, использование сессий и кук, переходы по ссылкам. Ещё вы, возможно, захотите проверить вероятный результат не только состояния DOM, но и сохранения данных (например, проверить были ли изменения сохранены в базе данных).</p>\n<p>В этом случае вам стоит использовать фреймворк <a href=\"https://www.cypress.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Cypress</a>, <a href=\"https://playwright.dev\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Playwright</a> или библиотеку <a href=\"https://pptr.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Puppeteer</a> так вы сможете перемещаться между несколькими маршрутами и проверять вероятные побочные эффекты не только в браузере, но и, возможно, на бэкенде.</p>","frontmatter":{"title":"Среды тестирования","next":null,"prev":"testing-recipes.html"},"fields":{"path":"content\\docs\\testing-environments.md","slug":"docs/testing-environments.html"}}},"pageContext":{"slug":"docs/testing-environments.html"}},"staticQueryHashes":[]}