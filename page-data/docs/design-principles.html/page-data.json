{"componentChunkName":"component---src-templates-docs-js","path":"/docs/design-principles.html","result":{"data":{"markdownRemark":{"html":"<p>Мы написали этот документ, чтобы у вас было лучшее представление о том, как мы решаем, что делает React, а что нет, и какова наша философия разработки. Хоть мы и рады видеть вклад сообщества, мы вряд ли выберем путь, который нарушает один или несколько из этих принципов.</p>\n<blockquote>\n<p><strong>Примечание:</strong></p>\n<p>Эта статья подразумевает глубокое понимание React. В ней описаны концепции разработки <em>самого React</em>, но не React-компонентов или приложений.</p>\n<p>Для знакомства с React почитайте главу <a href=\"/docs/thinking-in-react.html\">Философия React</a>.</p>\n</blockquote>\n<h3 id=\"composition\"><a href=\"#composition\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Композиция </h3>\n<p>Ключевая возможность React — это композиция компонентов. Компоненты, написанные разными людьми, должны хорошо работать вместе. Для нас важно, чтобы вы могли добавлять в компонент функциональность, не вызывая волну изменений по всему коду.</p>\n<p>Например, должна быть возможность вводить некое внутреннее состояние в компонент без изменения зависящих от него компонентов. Также должна быть возможность добавлять при необходимости код инициализации и разрушения в любой компонент.</p>\n<p>Нет ничего «плохого» в использовании состояния или методов жизненного цикла в компонентах. Как и любую мощную возможность, их стоит использовать в меру, но мы не собираемся их удалять. Напротив, мы считаем, что они являются неотъемлемой частью того, что делает React полезным. Возможно, мы добавим <a href=\"https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">больше паттернов функционального программирования</a> в будущем, но как внутреннее состояние, так и методы жизненного цикла будут частью этой модели.</p>\n<p>Компоненты часто описываются как «просто функции», но, по нашему мнению, они должны быть чем-то большим, чтобы быть полезными. Компоненты в React описывают поведение, которое можно композировать. Эта идея распространяется в том числе на рендеринг, жизненный цикл и состояние. Некоторые сторонние библиотеки, вроде <a href=\"https://facebook.github.io/relay/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay</a>, дополняют компоненты другими возможностями, например, описанием зависимостей данных. Вполне возможно, что эти идеи могут попасть в React в той или иной форме.</p>\n<h3 id=\"common-abstraction\"><a href=\"#common-abstraction\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Общая абстракция </h3>\n<p>В целом, мы <a href=\"https://www.youtube.com/watch?v=4anAwXYqLG8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">против добавления функциональности</a>, которая может быть реализована в пользовательских приложениях. Мы не хотим раздувать ваше приложение бесполезным кодом библиотеки. Но и у этого правила есть свои исключения.</p>\n<p>Например, если бы React не предоставлял поддержку внутреннего состояния или методов жизненного цикла, люди бы создавали собственные абстракции для них. Когда есть несколько конкурирующих абстракций, React не может применять или использовать их свойства. Для работы React нужен некий наименьший общий знаменатель.</p>\n<p>Вот почему иногда мы добавляем возможности в сам React. Если мы замечаем, что какая-то возможность реализуется плохо совместимым или неэффективным способом во многих компонентах, мы можем захотеть внедрить эту возможность в React. Мы подходим к таким изменениям со всей серьёзностью.\nЕсли мы добавляем новую возможность, значит мы уверены, что повышение уровня абстракции принесёт выгоду всей экосистеме. Хорошие примеры для этого — состояние, методы жизненного цикла, кросс-браузерная нормализация событий.</p>\n<p>Мы всегда обсуждаем с сообществом такие предложения по улучшению. Некоторые из этих обсуждений можно найти по метке <a href=\"https://github.com/facebook/react/issues?q=is:open+is:issue+label:%22Type:+Big+Picture%22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">«big picture»</a> в трекере задач React.</p>\n<h3 id=\"escape-hatches\"><a href=\"#escape-hatches\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Лазейки </h3>\n<p>React прагматичен. Это обусловлено потребностями продуктов, написанных в Facebook. Хоть на него и влияют некоторые не самые популярные парадигмы, такие как функциональное программирование, цель проекта — оставаться доступным для широкого круга разработчиков с разным уровнем опыта и навыками.</p>\n<p>Если мы хотим отказаться от паттерна, который нам не нравится, на нас лежит ответственность рассмотреть все существующие варианты его использования и <a href=\"/blog/2016/07/13/mixins-considered-harmful.html\">проинформировать сообщество об альтернативах</a>, прежде чем отказаться от него. Если какой-то полезный для создания приложений паттерн трудно описать декларативно, мы <a href=\"/docs/more-about-refs.html\">предоставим для него императивный API</a>. Если мы не можем найти идеальный API для того, что мы считаем необходимым во многих приложениях, мы <a href=\"/docs/legacy-context.html\">предоставим временный, частично работающий API</a>, при условии, что от него можно будет избавиться позже. Это оставляет открытой дверь для будущих улучшений.</p>\n<h3 id=\"stability\"><a href=\"#stability\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Стабильность </h3>\n<p>Мы ценим стабильность API. У нас в Facebook более 50 тысяч компонентов, использующих React. Многие другие компании, включая <a href=\"https://twitter.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Twitter</a> и <a href=\"https://www.airbnb.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Airbnb</a>, также активно используют React. Поэтому мы обычно нехотя меняем публичный API или поведение.</p>\n<p>Однако, мы считаем переоценённой идею, что стабильность — это когда «ничего не меняется». Она быстро приводит к застою. Вместо этого, мы предпочитаем воспринимать стабильность в смысле «это много используется в продакшене и когда что-то меняется, существует чёткий (и желательно автоматизированный) план миграции».</p>\n<p>Когда мы объявляем паттерн устаревшим, мы сперва изучаем как он используется внутри Facebook и добавляем предупреждения об устаревании. Это позволяет нам оценить масштабы последствий изменения. Иногда мы отменяем изменение, если видим, что ещё слишком рано приступать к его воплощению и нам нужно продумать стратегию продвижения кодовой базы к состоянию готовности.</p>\n<p>Если мы уверены, что изменение не слишком большое и для всех случаев использования возможна миграция, то предупреждение об устаревании публикуется перед OSS-сообществом. Мы тесно общаемся со многими React-пользователями вне Facebook, следим за популярными OSS-проектами и помогаем им исправлять устаревший код.</p>\n<p>Учитывая огромный размер кодовой базы React в Facebook, успешная внутренняя миграция часто является хорошим индикатором того, что в других компаниях также не будет проблем. Тем не менее, люди иногда указывают на неучтённые варианты использования и мы добавляем лазейки или пересматриваем подход.</p>\n<p>Ничто не объявляется устаревшим без веской причины. Мы понимаем, что иногда предупреждения об устаревании разочаровывают. Но они вводятся, так как это открывает дорогу улучшениям и новым возможностям, которые мы и сообщество считаем важными.</p>\n<p>Например, мы добавили <a href=\"/warnings/unknown-prop.html\">предупреждение о неизвестных DOM-свойствах</a> в React 15.2.0. Этим мы затронули многие проекты. Однако, исправление этого предупреждения важно для добавления в React поддержки <a href=\"https://github.com/facebook/react/issues/140\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">пользовательских атрибутов</a>. Подобная причина стоит за каждым объявлением об устаревании, которое мы добавляем.</p>\n<p>При добавлении предупреждения об устаревании, мы оставляем его пока актуальна текущая мажорная версия, <a href=\"/blog/2016/02/19/new-versioning-scheme.html\">изменяя поведение только в следующей мажорной версии</a>. Если изменение создаёт много повторяющейся ручной работы, мы публикуем <a href=\"https://www.youtube.com/watch?v=d0pOgY8__JM\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codemod-скрипт</a>, который автоматизирует большую часть изменений. Codemod-скрипты дают нам возможность двигаться вперёд, не закапываясь в куче кода. Рекомендуем вам тоже их использовать.</p>\n<p>Вы можете найти ранее опубликованные codemod-скрипты в <a href=\"https://github.com/reactjs/react-codemod\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-codemod</a> репозитории.</p>\n<h3 id=\"interoperability\"><a href=\"#interoperability\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Совместимость </h3>\n<p>Мы придаём большое значение совместимости с существующими системами и возможности постепенного внедрения. В Facebook есть много кода, написанного не на React. Сайт использует смесь из XHP — системы серверных компонент, внутренних UI-библиотек, которые пришли до React, и самого React. Для нас важно, чтобы любая продуктовая команда могла <a href=\"https://www.youtube.com/watch?v=BF58ZJ1ZQxY\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">начать использовать React для небольшой возможности</a>, а не делать ставку на переписывание своего кода.</p>\n<p>По этой причине React предоставляет лазейки для работы с изменяемыми моделями и пытается хорошо работать вместе с другими UI-библиотеками. Вы можете обернуть существующий императивный UI в декларативный компонент и наоборот. Это очень важно для постепенного внедрения.</p>\n<h3 id=\"scheduling\"><a href=\"#scheduling\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Планирование </h3>\n<p>Даже если компоненты описаны как функции, при использовании React они не вызываются напрямую. Каждый компонент возвращает <a href=\"/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree\">описание того, что должно быть отрендерено</a>. Описание может включать как пользовательские компоненты, такие как <code class=\"gatsby-code-text\">&lt;LikeButton></code>, так и платформо-зависимые компоненты, такие как <code class=\"gatsby-code-text\">&lt;div></code>. В дальнейшем в какой-то момент React может «развернуть» <code class=\"gatsby-code-text\">&lt;LikeButton></code> и фактически применить изменения к UI-дереву в соответствии с результатами рекурсивного рендеринга компонентов.</p>\n<p>Это тонкое, но сильное различие. Поскольку вы не вызываете этот функциональный компонент, а позволяете React вызывать его, это означает, что React может отложить вызов при необходимости. В текущей реализации React рекурсивно обходит дерево и вызывает функции рендера всего обновлённого дерева за один проход. Но в будущем он может начать <a href=\"https://github.com/facebook/react/issues/6170\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">задерживать некоторые обновления, чтобы избежать потери кадров</a>.</p>\n<p>Это частая тема в архитектуре React. Некоторые популярные библиотеки реализуют подход «прослушивание», когда вычисления выполняются при появлении новых данных. React, наоборот, придерживается подхода «опрашивание», когда вычисления могут быть запрошены при необходимости.</p>\n<p>React не является универсальной библиотекой обработки данных. Это библиотека для создания пользовательских интерфейсов. Мы считаем, что приложение должно знать какие вычисления сейчас актуальны, а какие нет.</p>\n<p>Если что-то находится вне экрана, можно отложить любую связанную с этим логику. Если данные поступают быстрее, чем кадры успевают обновиться, можно объединить их и обновлять пакетами. Мы можем приоритизировать работу, вызванную пользовательским взаимодействием (например, анимация нажатия кнопки), над менее важной фоновой работой (например, рендеринг только что загруженного из сети компонента), чтобы избежать потери кадров.</p>\n<p>Уточним, что это на сегодняшний день ещё не реализовано. Однако, подобная свобода иллюстрирует, почему мы предпочитаем контролировать планирование и почему функция <code class=\"gatsby-code-text\">setState()</code> работает асинхронно. Концептуально мы думаем об этом как о «планировании обновления».</p>\n<p>Нам будет сложнее контролировать планирование, если мы позволим пользователям использовать подход «выталкивание при наличии данных», распространённый в <a href=\"https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%80%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%25B\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">функциональном реактивном программировании</a>. Мы хотим, чтобы наш код был «связующим».</p>\n<p>Ключевая задача для React — минимизировать количество пользовательского кода, выполняемого перед возвращением обратно в React. Это гарантирует, что React сохранит возможность планировать и разбивать работу на части в соответствии с тем, что ему известно о UI.</p>\n<p>В команде есть внутренняя шутка, что React должен был называться «Планировщик», потому что React не хочет быть полностью «реактивным».</p>\n<h3 id=\"developer-experience\"><a href=\"#developer-experience\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Удобство разработки </h3>\n<p>Нам важно сделать процесс разработки комфортным.</p>\n<p>Например, мы поддерживаем расширение браузера <a href=\"https://github.com/facebook/react/tree/main/packages/react-devtools\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React DevTools</a>, при помощи которого можно просматривать дерево React-компонентов в Chrome и Firefox. Мы часто слышим, что это повышает производительность как инженеров Facebook, так и остального сообщества.</p>\n<p>Мы также стараемся сделать всё возможное, чтобы предоставить полезные предупреждения для разработчиков. Например, во время разработки React предупреждает вас, если теги вложены непонятным для браузера образом, или если в API сделана опечатка. Предупреждения и связанные с ними проверки являются основной причиной, почему версия React для разработчиков медленнее, чем продакшен-версия.</p>\n<p>Наблюдение за тем, как React используется внутри Facebook помогает нам выявить и понять наиболее частые ошибки, а также как предотвратить их заранее. Когда мы добавляем новые возможности, мы стараемся предугадать частые ошибки и предупредить о них.</p>\n<p>Мы всегда ищем способы сделать разработку удобнее, поэтому с радостью обсуждаем ваши идеи и принимаем вклады, приносящие улучшения.</p>\n<h3 id=\"debugging\"><a href=\"#debugging\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Отладка </h3>\n<p>Когда что-то идёт не так, важно иметь возможность найти источник ошибки в кодовой базе. В React в этом помогают пропсы и состояние.</p>\n<p>Если вы видите, что на экране что-то не так, можете открыть React DevTools, найти компонент, отвечающий за рендеринг, а затем проверить правильность его пропсов и состояния. Если они в порядке, значит проблема в <code class=\"gatsby-code-text\">render()</code> функции компонента или в какой-то функции, вызываемой в <code class=\"gatsby-code-text\">render()</code>. Проблема изолирована.</p>\n<p>Если состояние неверно, значит проблему спровоцировал один из вызовов <code class=\"gatsby-code-text\">setState()</code> в этом файле. Её также относительно просто найти и исправить, так как в одном файле обычно всего несколько вызовов <code class=\"gatsby-code-text\">setState()</code>.</p>\n<p>Если пропсы неверны, вы можете пройти в инспекторе вверх по дереву, в поисках первого компонента, который передал неправильные пропсы вниз.</p>\n<p>Для React очень важна возможность отследить любой UI до данных, на которых он построен, в виде текущих пропсов и состояния. Одной из явных целей в нашем дизайне является то, чтобы состояние не «пропадало» в замыканиях и вычислениях, и было доступно напрямую в React.</p>\n<p>Хотя UI динамичен, мы считаем, что синхронный рендер пропсов и состояния превращают отладку из гадания в скучный, но конечный процесс. Мы хотели бы сохранить это ограничение в React, хотя это усложняет некоторые варианты использования, такие как сложная анимация.</p>\n<h3 id=\"configuration\"><a href=\"#configuration\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Конфигурация </h3>\n<p>Мы считаем, что возможность глобальной конфигурации во время выполнения, может стать проблемой.</p>\n<p>Например, иногда нас просят реализовать такую функцию, как <code class=\"gatsby-code-text\">React.configure(options)</code> или <code class=\"gatsby-code-text\">React.register(component)</code>. Но это создаёт множество проблем, и мы не знаем хороших решений для них.</p>\n<p>Что, если кто-то вызовет такую функцию из сторонней библиотеки компонентов? Что, если одно React-приложение встраивает другое React-приложение и нужные им конфигурации несовместимы? Как сторонний компонент может указать, что ему нужна определённая конфигурация? Мы думаем, что глобальная конфигурация плохо работает с композицией. Поскольку композиция для React первостепенна, мы не предоставляем возможности глобальной конфигурации в коде.</p>\n<p>Однако, мы предоставляем некоторые глобальные настройки на уровне сборки. Например, мы предоставляем отдельные сборки для разработки и продакшена. В будущем мы можем <a href=\"https://github.com/facebook/react/issues/6627\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">добавить профилирующую сборку</a>. Мы также открыты для рассмотрения других флагов сборки.</p>\n<h3 id=\"beyond-the-dom\"><a href=\"#beyond-the-dom\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>За пределами DOM </h3>\n<p>Мы видим ценность React в том, что он позволяет писать компоненты, в которых меньше ошибок и которые хорошо сочетаются друг с другом. Изначальной целью рендеринга для React является DOM, но <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Native</a> не менее важен, как для Facebook, так и для сообщества.</p>\n<p>Быть независимым от визуализации — важное ограничение в дизайне React. Это создаёт некоторые накладные расходы во внутренних представлениях. С другой стороны, любые улучшения ядра переносятся между платформами.</p>\n<p>Наличие единой модели программирования позволяет нам создавать инженерные команды вокруг продуктов, а не платформ. Пока компромисс того стоил.</p>\n<h3 id=\"implementation\"><a href=\"#implementation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Реализация </h3>\n<p>Мы стараемся предоставлять изящный API везде, где это возможно. Но мы гораздо меньше обеспокоены изящностью реализации. Реальный мир далёк от идеала и мы предпочитаем добавлять некрасивый код в библиотеку в разумной степени, если это означает, что пользователю не нужно его писать. Когда мы оцениваем новый код, мы смотрим на правильность реализации, производительность и удобство разработки. Изящность вторична.</p>\n<p>Мы предпочитаем скучный код умному. Код одноразовый и часто меняется. Поэтому важно, чтобы он <a href=\"https://youtu.be/4anAwXYqLG8?t=13m9s\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">не привносил новых внутренних абстракций без крайней необходимости</a>. Подробный код, который легко перемещать, изменять и удалять, предпочтительнее изящного, преждевременно абстрагированного и трудно изменяемого кода.</p>\n<h3 id=\"optimized-for-tooling\"><a href=\"#optimized-for-tooling\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Оптимизирован для инструментов </h3>\n<p>Некоторые часто используемые API имеют длинные имена. Например, мы <a href=\"https://github.com/reactjs/react-future/issues/40#issuecomment-142442124\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">специально</a> используем <code class=\"gatsby-code-text\">componentDidMount()</code> вместо <code class=\"gatsby-code-text\">didMount()</code> или <code class=\"gatsby-code-text\">onMount()</code>. Цель в том, чтобы сделать точки взаимодействия с библиотекой хорошо заметными.</p>\n<p>В такой большой кодовой базе, как у Facebook, очень важно иметь возможность поиска использования определённых API. Мы ценим разные длинные имена, особенно для функциональности, которую следует использовать редко. Например, <code class=\"gatsby-code-text\">dangerouslySetInnerHTML</code> трудно пропустить на кодревью.</p>\n<p>Оптимизация для поиска также важна, так как мы зависим от <a href=\"https://www.youtube.com/watch?v=d0pOgY8__JM\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codemod</a>-скриптов для внесения критических изменений. Мы хотим, чтобы было легко и безопасно вносить большие автоматизированные изменения в кодовую базу, а уникальные длинные имена нам в этом помогают. Подобно этому, уникальные имена позволяют легко создавать собственные <a href=\"https://github.com/yannickcr/eslint-plugin-react\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">правила анализа</a> использования React, не беспокоясь о возможных ложных срабатываниях.</p>\n<p>Аналогичную роль играет <a href=\"/docs/introducing-jsx.html\">JSX</a>. Хотя он необязателен для работы React, мы широко используем его в Facebook как по эстетическим, так и по практическим соображениям.</p>\n<p>В нашей кодовой базе JSX предоставляет однозначную подсказку инструментам, что они работают с деревом React-элементов. Это позволяет добавлять оптимизации во время сборки, такие как <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">всплытие неизменяющихся элементов</a>, безопасный анализ и использование внутреннего компонента codemod, а также добавление в предупреждения <a href=\"https://github.com/facebook/react/pull/6771\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">пути до исходников JSX-кода</a>.</p>\n<h3 id=\"dogfooding\"><a href=\"#dogfooding\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Использование React в Facebook </h3>\n<p>Мы стараемся решать проблемы, поднятые сообществом. Однако, скорее всего, мы будем отдавать приоритет тем проблемам, с которыми люди <em>также</em> сталкиваются внутри Facebook. Возможно нелогично, но мы думаем, что это основная причина, по которой сообщество может полагаться на React.</p>\n<p>Интенсивное внутреннее использование даёт нам уверенность в том, что React не исчезнет завтра. React был создан в Facebook для решения своих проблем. Он приносит ощутимую бизнес-ценность компании и используется во многих её продуктах. Использование своего продукта у себя позволяет оставаться нашему видению проекта ясным и сфокусированным на движении вперёд.</p>\n<p>Это не означает, что мы игнорируем вопросы, поднятые сообществом. Например, мы добавили поддержку <a href=\"/docs/webcomponents.html\">web-компонентов</a> и <a href=\"https://github.com/facebook/react/pull/6243\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SVG</a> в React, хотя мы не используем их внутри. Мы активно <a href=\"https://github.com/facebook/react/issues/2686\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">следим за вашими проблемами</a> и <a href=\"/blog/2016/07/11/introducing-reacts-error-code-system.html\">устраняем их</a> по мере наших возможностей. Сообщество — это то, что делает React особенным для нас и мы рады внести свой вклад.</p>\n<p>Выпустив много OSS-проектов в Facebook, мы поняли, что попытка сделать всех счастливыми одновременно приводит к созданию слишком общих проектов, которые плохо развиваются. Мы также обнаружили, что выбор узкой аудитории и фокусировка ней, напротив приносит положительный конечный результат. Именно это мы сделали с React. И до сих пор решение проблем, с которыми сталкиваются продуктовые команды Facebook, хорошо транслировались на OSS-сообщество.</p>\n<p>Недостатком этого подхода является то, что иногда мы не уделяем достаточного внимания тем вещам, с которыми командам Facebook не приходится сталкиваться, такими как опыт «начала работы». Мы хорошо знаем об этой проблеме. И думаем над тем как сделать лучше так, чтобы это принесло пользу всем в сообществе, не совершая тех же ошибок, которые мы делали в OSS-проектах до этого.</p>","frontmatter":{"title":"Принципы проектирования React","next":null,"prev":"implementation-notes.html"},"fields":{"path":"content\\docs\\design-principles.md","slug":"docs/design-principles.html"}}},"pageContext":{"slug":"docs/design-principles.html"}},"staticQueryHashes":[]}